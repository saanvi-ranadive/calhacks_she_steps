"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useBarAnimator = exports.BarVisualizer = void 0;
var _componentsReact = require("@livekit/components-react");
var _reactNative = require("react-native");
var _hooks = require("../hooks");
var _react = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const defaultBarOptions = {
  maxHeight: 1,
  minHeight: 0.2,
  barColor: '#888888',
  barWidth: 24,
  barBorderRadius: 12
};
const sequencerIntervals = new Map([['connecting', 2000], ['initializing', 2000], ['listening', 500], ['thinking', 150]]);
const getSequencerInterval = (state, barCount) => {
  if (state === undefined) {
    return 1000;
  }
  let interval = sequencerIntervals.get(state);
  if (interval) {
    switch (state) {
      case 'connecting':
        // case 'thinking':
        interval /= barCount;
        break;
      default:
        break;
    }
  }
  return interval;
};
/**
 * @beta
 */

/**
 * Visualizes audio signals from a TrackReference as bars.
 * If the `state` prop is set, it automatically transitions between VoiceAssistant states.
 * @beta
 *
 * @remarks For VoiceAssistant state transitions this component requires a voice assistant agent running with livekit-agents \>= 0.9.0
 *
 * @example
 * ```tsx
 * function SimpleVoiceAssistant() {
 *   const { state, audioTrack } = useVoiceAssistant();
 *   return (
 *    <BarVisualizer
 *      state={state}
 *      trackRef={audioTrack}
 *    />
 *   );
 * }
 * ```
 */
const BarVisualizer = ({
  style = {},
  state,
  barCount = 5,
  trackRef,
  options
}) => {
  let trackReference = (0, _componentsReact.useMaybeTrackRefContext)();
  if (trackRef) {
    trackReference = trackRef;
  }
  const opacityAnimations = (0, _react.useRef)([]).current;
  let magnitudes = (0, _hooks.useMultibandTrackVolume)(trackReference, {
    bands: barCount
  });
  let opts = {
    ...defaultBarOptions,
    ...options
  };
  const highlightedIndices = useBarAnimator(state, barCount, getSequencerInterval(state, barCount) ?? 100);
  (0, _react.useEffect)(() => {
    let animations = [];
    for (let i = 0; i < barCount; i++) {
      if (!opacityAnimations[i]) {
        opacityAnimations[i] = new _reactNative.Animated.Value(0.3);
      }
      let targetOpacity = 0.3;
      if (highlightedIndices.includes(i)) {
        targetOpacity = 1;
      }
      animations.push(_reactNative.Animated.timing(opacityAnimations[i], {
        toValue: targetOpacity,
        duration: 250,
        useNativeDriver: true
      }));
    }
    let parallel = _reactNative.Animated.parallel(animations);
    parallel.start();
    return () => {
      parallel.stop();
    };
  }, [highlightedIndices, barCount, opacityAnimations]);
  let bars = [];
  magnitudes.forEach((value, index) => {
    let coerced = Math.min(opts.maxHeight, Math.max(opts.minHeight, value));
    let coercedPercent = Math.min(100, Math.max(0, coerced * 100));
    let opacity = opacityAnimations[index] ?? new _reactNative.Animated.Value(0.3);
    let barStyle = {
      opacity: opacity,
      backgroundColor: opts.barColor,
      borderRadius: opts.barBorderRadius,
      width: opts.barWidth
    };
    bars.push( /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
      key: index,
      style: [{
        height: `${coercedPercent}%`
      }, barStyle]
    }));
  });
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: {
      ...style,
      ...styles.container
    }
  }, bars);
};
exports.BarVisualizer = BarVisualizer;
const styles = _reactNative.StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-evenly'
  }
});
const useBarAnimator = (state, columns, interval) => {
  const [index, setIndex] = (0, _react.useState)(0);
  const [sequence, setSequence] = (0, _react.useState)([[]]);
  (0, _react.useEffect)(() => {
    if (state === 'thinking') {
      setSequence(generateListeningSequenceBar(columns));
    } else if (state === 'connecting' || state === 'initializing') {
      const seq = [...generateConnectingSequenceBar(columns)];
      setSequence(seq);
    } else if (state === 'listening') {
      setSequence(generateListeningSequenceBar(columns));
    } else if (state === undefined) {
      // highlight everything
      setSequence([new Array(columns).fill(0).map((_, idx) => idx)]);
    } else {
      setSequence([[]]);
    }
    setIndex(0);
  }, [state, columns]);
  const animationFrameId = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    let startTime = performance.now();
    const animate = time => {
      const timeElapsed = time - startTime;
      if (timeElapsed >= interval) {
        setIndex(prev => prev + 1);
        startTime = time;
      }
      animationFrameId.current = requestAnimationFrame(animate);
    };
    animationFrameId.current = requestAnimationFrame(animate);
    return () => {
      if (animationFrameId.current !== null) {
        cancelAnimationFrame(animationFrameId.current);
      }
    };
  }, [interval, columns, state, sequence.length]);
  return sequence[index % sequence.length];
};
exports.useBarAnimator = useBarAnimator;
const generateListeningSequenceBar = columns => {
  const center = Math.floor(columns / 2);
  const noIndex = -1;
  return [[center], [noIndex]];
};
const generateConnectingSequenceBar = columns => {
  const seq = [[]];
  for (let x = 0; x < columns; x++) {
    seq.push([x, columns - 1 - x]);
  }
  return seq;
};
//# sourceMappingURL=BarVisualizer.js.map